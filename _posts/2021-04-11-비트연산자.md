# 비트 연산자

메모리에서 숫자를 표현하는 비트를 직접 조작하는 저수준의 연산자 입니다.<br />

ECMAScript에서 숫자는 모두 IEEE-754 64비트 형식으로 저장되지만, 비트 연산시 32비트 정수로 변화나 후 비트 연산을 처리하고 다시 64비트로 변경합니다.

부호가 있는(-, +) 정수는 32비트 중 31비트를 사용하여 정수의 숫자 값을 나타내고,<br />
32번째 비트는 숫자의 부호(-, +)를 나타내는데 사용합니다.

## 음수 이진코드 처리

음수는 이진 코드로 저장되지만 2의 보수 형식으로 저장합니다.<br />

2의 보수 변경 단계

- 절대값의 2진 표현을 구한다
- 숫자에 대해서 1의 보수를 구한다.
  - 모든 0 --> 1, 1 --> 0 으로 바꾼다.
- 결과에 1을 더한다.

### 1의 보수

음수를 표현하기 위해 나온 방식은 1의 보수에 대한 표현이다.<br />
`0001 0010` 을 1의 보수로 표현한다면<br />
`1110 1101` 이 된다.<br />

### 1의 보수의 문제점

1의 보수에서 `0000 0000`과 `1111 1111`모두 `0`을 나타내기 때문에 `0`이 `2`개가 된다.<br />
이런 문제를 해결하기 위해 2의 보수방식을 취한다.

2의 보수는 10진수와 상호 변경이 어렵지만 양수 인것처럼 바로 더해서 계산이 가능하다.

```js
0000 0011 // 3 : --> 첫 번째 비트가 0이므로 보수를 취하지 않는다.
1111 1011 // -5 : --> 첫번째 비트가 1이므로 음수(-)값이다. --> 1을 뺀다 1111 1010 --> 0과 1을 뒤집는다. 1000 0101 -5(1+4)
---------
1111 1110 // -5 : --> 첫번째 비트가 1이므로 음수(-)값이다 --> 1을 뺀다 1111 1101 --> 0과 1을 뒤집는다. 1000 0010 -2(2)
```

```js
1111 1011 // -5 : --> 첫번째 비트가 1이므로 음수(-)값이다 --> 1을 뺀다 1111 1010 --> 0과 1을 뒤집는다. 1000 0101 -5(1+4)
1111 1001 // -7 -->  첫번째 비트가 1이므로 음수(-)값이다 --> 1을 뺀다. 1111 1000 --> 0과 1을 뒤집는다. 1000 0111 -7(1+2+4)
---------
1111 0100 // -12 --> 첫번째 비트가 1이므로 음수(-)값이다 --> 1을 뺀다. 1111 0011 --> 0과 1을 뒤집는다. 1000 1100 -12(4 + 8)
```

### -18을 비트로 표현해 보자

```js
// 18을 비트로 표현
0000 0000 0000 0000 0000 0000 0001 0010

// 1의 보수
1111 1111 1111 1111 1111 1111 1110 1101

// 2의 보수
1111 1111 1111 1111 1111 1111 1110 1110
```

- ECMAScript는 가능한 이런 복잡한 정보를 노출하려고 하지 않는다.<br />
- 음수를 2진 문자열로 얻으려면 다음과 같이 절대값의 2진 표현에 마이너스 부호를 붙인값을 얻는다.

```js
var num = -18;
num.toString(2); // "-10010"
```

## 비트 Not

틸드(`~`)를 사용하고 단순 피 연산자의 1의 보수를 반환한다.<br />
(모든 0 --> 1, 1 --> 0 으로 변경)

```js
~10; // -11
```

-11이 나오도록 계산한다음 다음과 같다.

1. `10`을 비트로 표현하면
1. `0000 1010`이 된다 `// (10).toString(2)`
1. not(`~`)으로 비트를 뒤집으면
1. `1111 0101`이 된다.
1. `1111 0101`를 10진법으로 변경하면
1. 첫 번째 비트가 `1`이므로 음수(-)이다.
1. 2의 보수를 취한다.
1. `1`을 뺀 비트는 `1111 0100`이 된다.
1. 0을 1로 변경하면 `1000 1011` 이다.
1. 이 값을 10진수로 계산한다면 11 (1+2+8)이 되고 첫 번째비트가 1이므로 -11이 된다.

따라서 `10`에 NOT(`~`)은 `-11`이 된다.

### 26의 비트 Not

```js
var a = 26;
var b = ~a;

b; // -27
```

> 결과적으로 숫자의 부호를 바꾼 후 1을 뺀 결과를 반환한다.

## 비트 AND

앰퍼센드(`&`)로 나타내며 피 연산자를 2개 취합니다.

| 첫 번째 피연산자 비트 | 두 번째 피연산자 비트 | 결과 |
| :-------------------: | :-------------------: | :--: |
|           1           |           1           |  1   |
|           1           |           0           |  0   |
|           0           |           1           |  0   |
|           0           |           0           |  0   |

> 두 비트가 모두 1인 경우 1을 반환한다.

```js
var result = 25 & 3;
console.log(result); // 1;

// 위 코드에 대한 비트 & 연산은 아래와 같다.
25  0000 0000 0000 0000 0000 0000 0001 1001 // 1 + 8 + 16
                      &
3   0000 0000 0000 0000 0000 0000 0000 0011 // 1 + 2
---------------------------------------------
1   0000 0000 0000 0000 0000 0000 0000 0001 // 1
```

### 실전 예제

```js
var options = [
  {
    value: 1,
    label: "아반떼",
  },
  {
    value: 2,
    label: "소나타",
  },
  {
    value: 4,
    label: "그랜저",
  },
  {
    value: 16,
    label: "G70",
  },
  {
    value: 32,
    label: "G80",
  },
];

var targets = 2 + 16;

var result = options.reduce((acc, car) => {
  if ((car.value & targets) > 0) {
    acc.push(car);
  }
  return acc;
}, []);

console.log(result); // [{ "value": 2, "label": "소나타" }, { value:16, label: "G70" }]
```

## 비트 OR

파이프 (`|`)로 나타내며 피연산자 2개를 취합니다.

| 첫 번째 피연산자 비트 | 두 번째 피연산자 비트 | 결과 |
| :-------------------: | :-------------------: | :--: |
|           1           |           1           |  1   |
|           1           |           0           |  1   |
|           0           |           1           |  1   |
|           0           |           0           |  0   |

> 두 비트중 하나라도 1인 경우 1을 반환한다.

```js
var result = 25 | 3;
console.log(result); // 1;

// 위 코드에 대한 비트 | 연산은 아래와 같다.
25  0000 0000 0000 0000 0000 0000 0001 1001 // 1 + 8 + 16
                      |
3   0000 0000 0000 0000 0000 0000 0000 0011 // 1 + 2
---------------------------------------------
1   0000 0000 0000 0000 0000 0000 0001 1011 // 1 + 2 + 8 + 16
```

## 비트 XOR

캐럿 (`^`)로 나타내며 피연산자 2개를 취합니다.

| 첫 번째 피연산자 비트 | 두 번째 피연산자 비트 | 결과 |
| :-------------------: | :-------------------: | :--: |
|           1           |           1           |  0   |
|           1           |           0           |  1   |
|           0           |           1           |  1   |
|           0           |           0           |  0   |

> 두 비트중 하나만 1인 경우 1을 반환한다.

```js
var result = 25 ^ 3;
console.log(result); // 1;

// 위 코드에 대한 비트 | 연산은 아래와 같다.
25  0000 0000 0000 0000 0000 0000 0001 1001 // 1 + 8 + 16
                      |
3   0000 0000 0000 0000 0000 0000 0000 0011 // 1 + 2
---------------------------------------------
1   0000 0000 0000 0000 0000 0000 0001 1010 // 2 + 8 + 16
```

### 토글 기능을 bit로 처리 할 수 있다.

```js

var flag = 0;
flag = flag^; // flag : 1
flag = flag^; // flag : 0
flag = flag^; // flag : 1
flag = flag^; // flag : 0
```

## 왼쪽 쉬프트

`<<`로 좌항의 모든 비트를 우항의 숫자만큼 왼쪽으로 옴직입니다.

```js
var result = 2 << 5;
console.log(result); // 64;

// 오른쪽 끝에 0으로 5개가 채워지고 기존 값은 그만큼 왼쪽으로 밀려난다.
2   0000 0000 0000 0000 0000 0000 0000 0010 // 2
                << 5
64  0000 0000 0000 0000 0000 0000 0100 0000 // 64
```

> 왼쪽 시프트는 피연산자의 부호(+, -)를 유지합니다.

## 부호 있는 오른쪽 시프트

`>>`로 나타내며 32비트 숫자의 모든 비트를 오른쪽으로 움직이되, 부호(+, -)를 유지합니다.

```js
var result = 64 >> 5;
console.log(result); // 64;

// 왼쪽 끝에 0으로 5개가 채워지고 기존 값은 그만큼 오른쪽으로 밀려난다.
64  0000 0000 0000 0000 0000 0000 0100 0000 // 64
                >> 5
2   0000 0000 0000 0000 0000 0000 0000 0010 // 2
```

## 부호 없는 오른쪽 시프트

`>>>`로 나타내며 32비트 숫자의 모든 비트를 오른쪽으로 움직입니다.<br />

### 양수에 부호 없는 오른쪽 시프트를 적용한 결과를 부호 있는 오른쪽 시프트 결과와 같습니다.

```js
var result = 64 >> 5;
console.log(result); // 64;

// 왼쪽 끝에 0으로 5개가 채워지고 기존 값은 그만큼 오른쪽으로 밀려난다.
64  0000 0000 0000 0000 0000 0000 0100 0000 // 64
                >> 5
2   0000 0000 0000 0000 0000 0000 0000 0010 // 2
```

### 음수에서 부호 있는 오른쪽 시프트와 달리 빈 비트는 숫자의 부호와 관계없이 0으로 채워진다.

부호 없는 오른쪽 시프트 연산자는 음수의 2진 표현을 양수로 간주한다.<br />
음수는 절대값의 2의 보수이므로 아래와 같이 매우 큰 숫자가 된다.

```js
var result = -64 >>> 5;
console.log(result); // 64;

// 왼쪽 끝에 0으로 5개가 채워지고 기존 값은 그만큼 오른쪽으로 밀려난다.
64         1111 1111 1111 1111 1111 1111 1100 0000 // -64
                >> 5
134217728  0000 0111 1111 1111 1111 1111 1111 1110 // 2 + 4 + 8 + 16 + 32 + 64 + 128 + 256 + 512 + 1024 + 2048 + 4096 + 8192 + 16384 + 32768 + 65536 + 131072 + 262144 + 524288 + 1048576 + 2097152 + 4194304 + 8388608 + 16777216 + 33554432 + 67108864 = 134217728
```
