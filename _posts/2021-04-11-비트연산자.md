# 비트 연산자

메모리에서 숫자를 표현하는 비트를 직접 조작하는 저수준의 연산자 입니다.<br />

ECMAScript에서 숫자는 모두 `IEEE-754` `64`비트 형식으로 저장되지만,
비트 연산시 `32`비트 정수로 변환 후 비트 연산을 처리하고 다시 `64`비트로 변경합니다.

부호가 있는(-, +) 정수는 `32`비트 중 `31`개 비트를 사용하여 정수의 숫자 값을 나타내고,<br />
`32`번째 비트는 숫자의 부호(-, +)를 나타내는데 사용합니다.

## 비트 Not

틸드(`~`)를 사용하며 단순 피 연산자의 1의 보수를 반환한다.<br />
(모든 0 --> 1, 1 --> 0 으로 변경)

```js
~10; // -11
```

그런데 왜 `-11`이 결과 값일까?

피연산자의 1의 보수 결과를 10진수로 계산되는 과정은 다음과 같다.

1. `10`을 비트로 표현하면
2. `0000 1010`이다. `// (10).toString(2)`
3. `NOT(~)`를 사용하여 비트값을 뒤집었기 대문에
4. `0000 1010` 은
5. `1111 0101` 이 된다.
6. `1111 0101` 를 `10`진법으로 변경하면 다음과 같은 순서를 따른다.
7. 첫 번째 비트가 `1`이므로 음수 이므로
8. `1111 0101` 에서 `1`을 뺀다.
9. `1111 0100` 이 된다.
10. `1111 0100` 을 `0`과 `1`을 뒤집는다.
11. `1000 1011` 첫 번째 비트는 부호 비트 이므로 첫 번째 비트를 제외하고 0 1을 뒤집는다.
12. `1000 1011` 를 계산한다면 `-11` 이 된다. (8+ 2+ 1)

따라서 `~10`은 `-11`이 된다.

### 26의 비트 Not

```js
var a = 26;
var b = ~a;

b; // -27
```

> 결과적으로 숫자의 부호를 바꾼 후 1을 뺀 결과를 반환한다.

### Q.

```
~-100; // 결과는?
```

## 비트 AND

앰퍼센드(`&`)로 나타내며 피 연산자를 2개 취합니다.

| 첫 번째 피연산자 비트 | 두 번째 피연산자 비트 | 결과 |
| :-------------------: | :-------------------: | :--: |
|           1           |           1           |  1   |
|           1           |           0           |  0   |
|           0           |           1           |  0   |
|           0           |           0           |  0   |

> 두 비트가 모두 1인 경우 1을 반환한다.

```js
var result = 25 & 3;
console.log(result); // 1;

// 위 코드에 대한 비트 & 연산은 아래와 같다.
25  0000 0000 0000 0000 0000 0000 0001 1001 // 1 + 8 + 16
                      &
3   0000 0000 0000 0000 0000 0000 0000 0011 // 1 + 2
---------------------------------------------
1   0000 0000 0000 0000 0000 0000 0000 0001 // 1
```

### 실전 예제

- 권한 목록 `options`가 주어지고
- `options`를 기반으로 멀티 셀렉트 박스가 사용자에게 제공될 때
- `options`에서 선택한 값들에 대한 정보를 하나의 필드로 전달할 수 있다.

```js
var options = [
  {
    value: 1,
    label: "아반떼",
  },
  {
    value: 2,
    label: "소나타",
  },
  {
    value: 4,
    label: "그랜저",
  },
  {
    value: 16,
    label: "G70",
  },
  {
    value: 32,
    label: "G80",
  },
];

var targets = 2 + 16;

var result = options.reduce((acc, car) => {
  if ((car.value & targets) > 0) {
    acc.push(car);
  }
  return acc;
}, []);

console.log(result); // [{ "value": 2, "label": "소나타" }, { value:16, label: "G70" }]


// 비트 연산

0000 0010 // 2
0001 0000 // 16
--------- // or
0001 0010 // 2 + 16


0001 0010 // 18 ( 2 + 16)
0000 0100 // 4
--------- // 18 & 4 and 연산
0000 0000


0001 0010  // 18 ( 2 + 16)
0001 0000  // 16
--------- // 18 & 16 and 연산
0001 0000  // 16

```

## 비트 OR

파이프 (`|`)로 나타내며 피연산자 2개를 취합니다.

| 첫 번째 피연산자 비트 | 두 번째 피연산자 비트 | 결과 |
| :-------------------: | :-------------------: | :--: |
|           1           |           1           |  1   |
|           1           |           0           |  1   |
|           0           |           1           |  1   |
|           0           |           0           |  0   |

> 두 비트중 하나라도 1인 경우 1을 반환한다.

```js
var result = 25 | 3;
console.log(result); // 1;

// 위 코드에 대한 비트 | 연산은 아래와 같다.
25  0000 0000 0000 0000 0000 0000 0001 1001 // 1 + 8 + 16
                      |
3   0000 0000 0000 0000 0000 0000 0000 0011 // 1 + 2
---------------------------------------------
1   0000 0000 0000 0000 0000 0000 0001 1011 // 1 + 2 + 8 + 16
```

## 비트 XOR

캐럿 (`^`)로 나타내며 피연산자 2개를 취합니다.

| 첫 번째 피연산자 비트 | 두 번째 피연산자 비트 | 결과 |
| :-------------------: | :-------------------: | :--: |
|           1           |           1           |  0   |
|           1           |           0           |  1   |
|           0           |           1           |  1   |
|           0           |           0           |  0   |

> 두 비트중 하나만 1인 경우 1을 반환한다.

```js
var result = 25 ^ 3;
console.log(result); // 1;

// 위 코드에 대한 비트 | 연산은 아래와 같다.
25  0000 0000 0000 0000 0000 0000 0001 1001 // 1 + 8 + 16
                      |
3   0000 0000 0000 0000 0000 0000 0000 0011 // 1 + 2
---------------------------------------------
1   0000 0000 0000 0000 0000 0000 0001 1010 // 2 + 8 + 16
```

### 토글 기능을 bit로 처리 할 수 있다.

```js

var flag = 0;
flag = flag^; // flag : 1
flag = flag^; // flag : 0
flag = flag^; // flag : 1
flag = flag^; // flag : 0
```

## 왼쪽 쉬프트

`<<`로 좌항의 모든 비트를 우항의 숫자만큼 왼쪽으로 옴직입니다.

```js
var result = 2 << 5;
console.log(result); // 64;

// 오른쪽 끝에 0으로 5개가 채워지고 기존 값은 그만큼 왼쪽으로 밀려난다.
2   0000 0000 0000 0000 0000 0000 0000 0010 // 2
                << 5
64  0000 0000 0000 0000 0000 0000 0100 0000 // 64
```

> 왼쪽 시프트는 피연산자의 부호(+, -)를 유지합니다.

## 부호 있는 오른쪽 시프트

`>>`로 나타내며 32비트 숫자의 모든 비트를 오른쪽으로 움직이되, 부호(+, -)를 유지합니다.

```js
var result = 64 >> 5;
console.log(result); // 64;

// 왼쪽 끝에 0으로 5개가 채워지고 기존 값은 그만큼 오른쪽으로 밀려난다.
0000 0000 0000 0000 0000 0000 0100 0000 // 64
                >> 5
0000 0000 0000 0000 0000 0000 0000 0010 // 2
```

## 부호 없는 오른쪽 시프트

`>>>`로 나타내며 32비트 숫자의 모든 비트를 오른쪽으로 움직입니다.<br />

### 양수에 부호 없는 오른쪽 시프트를 적용한 결과를 부호 있는 오른쪽 시프트 결과와 같습니다.

```js
var result = 64 >> 5;
console.log(result); // 64;

// 왼쪽 끝에 0으로 5개가 채워지고 기존 값은 그만큼 오른쪽으로 밀려난다.
0000 0000 0000 0000 0000 0000 0100 0000 // 64
                >> 5
0000 0000 0000 0000 0000 0000 0000 0010 // 2
```

### 음수에서 부호 있는 오른쪽 시프트와 달리 빈 비트는 숫자의 부호와 관계없이 0으로 채워진다.

부호 없는 오른쪽 시프트 연산자는 음수의 2진 표현을 양수로 간주한다.<br />
음수는 절대값의 2의 보수이므로 아래와 같이 매우 큰 숫자가 된다.

```js
var result = -64 >>> 5;
console.log(result); // 64;

// 왼쪽 끝에 0으로 5개가 채워지고 기존 값은 그만큼 오른쪽으로 밀려난다.
1111 1111 1111 1111 1111 1111 1100 0000 // -64
                >>> 5
0000 0111 1111 1111 1111 1111 1111 1110 // 134217726 = 2 + 4 + 8 + 16 + 32 + 64 + 128 + 256 + 512 + 1024 + 2048 + 4096 + 8192 + 16384 + 32768 + 65536 + 131072 + 262144 + 524288 + 1048576 + 2097152 + 4194304 + 8388608 + 16777216 + 33554432 + 67108864
```

```js
function decimalToBit(decimal) {
  return [...decimal.toString(2)]
    .reverse()
    .map((bit, index) => {
      if (index % 4 === 0 && index > 0) {
        bit += " ";
      }
      return bit;
    })
    .reverse()
    .join("");
}

decimalToBit(-64 >>> 5); // "111 1111 1111 1111 1111 1111 1110"
```

## 음수 이진코드 처리

음수는 이진 코드로 저장되지만 `2`의 보수 형식으로 저장합니다.<br />

### 1의 보수

음수를 표현하기 위해 `1`의 보수 표현을 사용할 수 있다.
`0001 0010` 을 `1`의 보수로 표현 한다면 `0`과 `1`을 뒤집어
`1110 1101` 로 표현한다.<br />

### 1의 보수의 문제점

`1`의 보수에서 `0000 0000`과 `1111 1111`모두 `0`을 나타내기 때문에
`0`을 표현하는 비트는 `2`가지가 된다.
이런 문제를 해결하기 위해 `2`의 보수방식을 취한다.

### `2`의 보수 구하기

1.  절대값의 `2`진 표현을 구한다.
1.  숫자에 대해서 1의 보수를 구한다.
    - 모든 `0 --> 1`, `1 --> 0` 으로 바꾼다.
1.  결과에 `1`을 더한다.

### -18 비트 표현

```js
// 18을 비트로 표현
0000 0000 0000 0000 0000 0000 0001 0010

// 1의 보수
1111 1111 1111 1111 1111 1111 1110 1101

// 2의 보수
1111 1111 1111 1111 1111 1111 1110 1110
```

> `2`의 보수는 `10`진수와 상호 변경이 어렵지만 양수인것 처럼 `&`로 바로 더해서 계산이 가능하다.

### 2의 보수를 이용한 & 연산 예

```js
// ## 음수, 양수 & 연산 예제 1

0 000 0011 // 3
1 000 0101 // -5
---------
1 111 1110

// & 연산한 결과 `1 111 1110`를 십진수로 계산한다면
// 1. 첫 번째 부호 비트가 1이므로 음수 값
1 111 1110
// 2. 1을 뺀다
1 111 1101
// 3. 0과 1을 뒤집는다.(부호 비트 제외)
1 000 0010
// 첫 번째 부호 비트가 1이므로 -2
```

```js
// ## 음수, 양수 & 연산 예제 2

1 111 1011 // -5
1 111 1001 // -7
---------
1 111 0100

// & 연산한 결과 `1 111 0100`를 십진수로 계산한다면
// 1. 첫 번째 부호 비트가 1이므로 음수 값
1 111 0100
// 2. 1을 뺀다
1 111 0011
// 3. 0과 1을 뒤집는다.(부호 비트 제외)
1 000 1100
// 첫 번째 부호 비트가 1이므로 -12 --> (4+8)
```

- ECMAScript는 가능한 이런 복잡한 정보를 노출하려고 하지 않는다.<br />
- 음수를 `2`진 문자열로 얻으려면 다음과 같이 절대값의 `2`진 표현에 마이너스 부호를 붙인값을 얻는다.

```js
var num = -18;
num.toString(2); // "-10010"
```
